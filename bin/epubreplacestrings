#!/usr/bin/env python
"""
This file is meant to be used on the text based content files of an epub. This allows for the replacement of common stylistic
changes and translation errors with the desired value making later book maintenance less of a hassle.
"""

import re
import sys
from dataclasses import dataclass
from typing import Any, Callable, Union

def out_of_the_blue_regex_handler(match):
    group1 = match.group(1)
    firstLetter = 'O'
    if group1 == 'a':
        firstLetter = 'o'

    group3 = match.group(3)

    return "{0}{1}".format(firstLetter, group3)

def no_wonder_regex_handler(match):
    group1 = match.group(1)
    firstLetter = 'N'
    if group1 == 'l':
        firstLetter = 'n'

    group2 = match.group(2)

    return "{0}{1}".format(firstLetter + 'o', group2)

@dataclass
class replaceString:
    search: str
    replace: Union[str, Callable[[Any], str]]
    rational: str

regexesToReplace = (
    replaceString(
      search ="(\. ?){2}\.",
      replace ="…",
      rational ="Proper ellipses should be used where possible as it keeps things clean and consistent",
    ),
    replaceString(
      search ="(?<!!)--(?!>)",
      replace ="—",
      rational ="Em dashes should be used where possible as it keeps things clean and consistent",
    ),
    replaceString(
      search ="(?<!~)~(?!~)",
      replace ="!",
      rational ="Tildes should be replaced with an exclamation mark when they are by themselves as they seem interchangeable, though it could be another form of punctuation for drawing out the sound of the last letter used",
    ),
    replaceString(
      search =r"(B|b)y the by",
      replace =r"\1y the way",
      rational ="'By the by' seems to be an improper translation of 'By the way', so we should auto-correct it to its proper English idiom",
    ),
    replaceString(
      search =r"(A|a) bolt (o)(ut of the blue)",
      replace = out_of_the_blue_regex_handler,
      rational ="'a bolt out of the blue' seems to be an improper translation of 'out of the blue', so we should auto-correct it to its proper English idiom",
    ),
    replaceString(
      search =r"(L|l)ittle( wonder)",
      replace = no_wonder_regex_handler,
      rational ="'little wonder' seems to be an improper translation of 'no wonder', so we should auto-correct it to its proper English idiom",
    ),
    replaceString(
      search =r"(S|s)neaked",
      replace =r"\1nuck",
      rational ="Use snuck instead of sneaked as it is the more commonly used version of the word nowadays",
    ),
)

def replace_strings(text: str):
    for regexToReplace in regexesToReplace:
        text = re.sub(regexToReplace.search, regexToReplace.replace, text)

    return text

def replace_string_in_single_file(filePath: str):
    with open(filePath, "r+") as f:
        text = f.read()
        text = replace_strings(text)
        f.seek(0)
        f.write(text)
        f.truncate()
        f.close()

def parse_text_replacements(text: str):
    replaceValueToReplacement = {}
    lines = text.split('\n')

    if len(lines) <= 2:
        return replaceValueToReplacement

    # remove the markdown table header and divider lines
    lines.pop(0)
    lines.pop(0)
    
    for line in lines:
        lineParts = line.split('|')
        if len(lineParts) == 1:
            continue
        elif len(lineParts) != 4:
            print("Could not parse `" + line + "` because it does not have the proper amount of '|'s in it")
            continue

        replaceValueToReplacement[lineParts[1].strip()] = lineParts[2].strip()

    return replaceValueToReplacement

def replace_file_strings(text: str, findAllValuesToReplace: dict[str, str], numberOfHits: dict[str, int]):
    for valueToReplace, replacementValue in findAllValuesToReplace.items():
        hitsInText = text.count(valueToReplace)
        if valueToReplace in numberOfHits:
            numberOfHits[valueToReplace] += hitsInText
        else:
            numberOfHits[valueToReplace] = hitsInText

        text = text.replace(valueToReplace, replacementValue)

    return text

def replace_text_in_files(files: list[str], replaceValueFile: str):
  replacementValues = {}
  numberOfHits = {}
  with open(replaceValueFile, "r+") as f:
          text = f.read()
          text = replace_strings(text)
          replacementValues = parse_text_replacements(text)
          f.close()

  if replacementValues == {}:
      print ("no values were listed as needing replacing")
      return

  for file in files:
      with open(file, "r+") as f:
          text = f.read()
          text = replace_strings(text)
          text = replace_file_strings(text, replacementValues, numberOfHits)
          f.seek(0)
          f.write(text)
          f.truncate()
          f.close()
  
  for valueToReplace in replacementValues.keys():
      if valueToReplace not in numberOfHits or numberOfHits[valueToReplace] == 0:
          print("Did not find any replacements for `" + valueToReplace + "`")
      else:
          print("`" + valueToReplace + "` was replaced " + str(numberOfHits[valueToReplace]) + " time(s)")

# handle the logic for deciding which method to call and the parsing of params if need be
def main():
  if len(sys.argv) >= 3:
      mode = sys.argv[1]
      match mode:
        case 's':
            replace_string_in_single_file(sys.argv[2])

        case 'm':
            if len(sys.argv) < 4:
                print("Invalid number or params were provided. You must provide the following params:")
                print("mode, list of file paths separated by a comma, and path to a markdown file that has a table in where each row is a value to find and what it should be replaced with")
                return

            replace_text_in_files(sys.argv[2].split(','), sys.argv[3])

        case _:
            print("Invalid mode provided. Please provide one of the following modes:")
            print("s - run common text replacements against a single file")
            print("m - run common text replacements and a list of replacements from a file against one or more files that are provided")

if __name__ == "__main__":
    main()
